PERLFAQ5(1)           User Contributed Perl Documentation          PERLFAQ5(1)



NNAAMMEE
       perlfaq5 - Files and Formats ($Revision: 1.42 $, $Date: 2005/12/31
       00:54:37 $)

DDEESSCCRRIIPPTTIIOONN
       This section deals with I/O and the "f" issues: filehandles, flushing,
       formats, and footers.

       HHooww ddoo II fflluusshh//uunnbbuuffffeerr aann oouuttppuutt ffiilleehhaannddllee??  WWhhyy mmuusstt II ddoo tthhiiss??

       Perl does not support truly unbuffered output (except insofar as you
       can "syswrite(OUT, $char, 1)"), although it does support is "command
       buffering", in which a physical write is performed after every output
       command.

       The C standard I/O library (stdio) normally buffers characters sent to
       devices so that there isn’t a system call for each byte. In most stdio
       implementations, the type of output buffering and the size of the
       buffer varies according to the type of device. Perl’s _p_r_i_n_t_(_) and
       _w_r_i_t_e_(_) functions normally buffer output, while _s_y_s_w_r_i_t_e_(_) bypasses
       buffering all together.

       If you want your output to be sent immediately when you execute _p_r_i_n_t_(_)
       or _w_r_i_t_e_(_) (for instance, for some network protocols), you must set the
       handle’s autoflush flag. This flag is the Perl variable $│ and when it
       is set to a true value, Perl will flush the handle’s buffer after each
       _p_r_i_n_t_(_) or _w_r_i_t_e_(_). Setting $│ affects buffering only for the currently
       selected default file handle. You choose this handle with the one argu-
       ment _s_e_l_e_c_t_(_) call (see "$│" in perlvar and "select" in perlfunc).

       Use _s_e_l_e_c_t_(_) to choose the desired handle, then set its per-filehandle
       variables.

           $old_fh = select(OUTPUT_HANDLE);
           $│ = 1;
           select($old_fh);

       Some idioms can handle this in a single statement:

           select((select(OUTPUT_HANDLE), $│ = 1)[0]);

           $│ = 1, select $_ for select OUTPUT_HANDLE;

       Some modules offer object-oriented access to handles and their vari-
       ables, although they may be overkill if this is the only thing you do
       with them.  You can use IO::Handle:

           use IO::Handle;
           open(DEV, ">/dev/printer");   # but is this?
           DEV->autoflush(1);

       or IO::Socket:

           use IO::Socket;               # this one is kinda a pipe?
               my $sock = IO::Socket::INET->new( ’www.example.com:80’ );

           $sock->autoflush();

       HHooww ddoo II cchhaannggee oonnee lliinnee iinn aa ffiillee//ddeelleettee aa lliinnee iinn aa ffiillee//iinnsseerrtt aa
       lliinnee iinn tthhee mmiiddddllee ooff aa ffiillee//aappppeenndd ttoo tthhee bbeeggiinnnniinngg ooff aa ffiillee??

       Use the Tie::File module, which is included in the standard
       distribution since Perl 5.8.0.

       HHooww ddoo II ccoouunntt tthhee nnuummbbeerr ooff lliinneess iinn aa ffiillee??

       One fairly efficient way is to count newlines in the file. The follow-
       ing program uses a feature of tr///, as documented in perlop.  If your
       text file doesn’t end with a newline, then it’s not really a proper
       text file, so this may report one fewer line than you expect.

           $lines = 0;
           open(FILE, $filename) or die "Can’t open ‘$filename’: $!";
           while (sysread FILE, $buffer, 4096) {
               $lines += ($buffer =~ tr/\n//);
           }
           close FILE;

       This assumes no funny games with newline translations.

       HHooww ccaann II uussee PPeerrll’’ss ""--ii"" ooppttiioonn ffrroomm wwiitthhiinn aa pprrooggrraamm??

       "-i" sets the value of Perl’s $^I variable, which in turn affects the
       behavior of "<>"; see perlrun for more details.  By modifying the
       appropriate variables directly, you can get the same behavior within a
       larger program.  For example:

            # ...
            {
               local($^I, @ARGV) = (’.orig’, glob("*.c"));
               while (<>) {
                  if ($. == 1) {
                      print "This line should appear at the top of each file\n";
                  }
                  s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
                  print;
                  close ARGV if eof;              # Reset $.
               }
            }
            # $^I and @ARGV return to their old values here

       This block modifies all the ".c" files in the current directory, leav-
       ing a backup of the original data from each file in a new ".c.orig"
       file.

       HHooww ccaann II ccooppyy aa ffiillee??

       (contributed by brian d foy)

       Use the File::Copy module. It comes with Perl and can do a true copy
       across file systems, and it does its magic in a portable fashion.

               use File::Copy;

               copy( $original, $new_copy ) or die "Copy failed: $!";

       If you can’t use File::Copy, you’ll have to do the work yourself: open
       the original file, open the destination file, then print to the desti-
       nation file as you read the original.

       HHooww ddoo II mmaakkee aa tteemmppoorraarryy ffiillee nnaammee??

       If you don’t need to know the name of the file, you can use "open()"
       with "undef" in place of the file name.  The "open()" function creates
       an anonymous temporary file.

               open my $tmp, ’+>’, undef or die $!;

       Otherwise, you can use the File::Temp module.

         use File::Temp qw/ tempfile tempdir /;

         $dir = tempdir( CLEANUP => 1 );
         ($fh, $filename) = tempfile( DIR => $dir );

         # or if you don’t need to know the filename

         $fh = tempfile( DIR => $dir );

       The File::Temp has been a standard module since Perl 5.6.1.  If you
       don’t have a modern enough Perl installed, use the "new_tmpfile" class
       method from the IO::File module to get a filehandle opened for reading
       and writing.  Use it if you don’t need to know the file’s name:

           use IO::File;
           $fh = IO::File->new_tmpfile()
               or die "Unable to make new temporary file: $!";

       If you’re committed to creating a temporary file by hand, use the pro-
       cess ID and/or the current time-value.  If you need to have many tempo-
       rary files in one process, use a counter:

           BEGIN {
               use Fcntl;
               my $temp_dir = -d ’/tmp’ ? ’/tmp’ : $ENV{TMPDIR} ││ $ENV{TEMP};
               my $base_name = sprintf("%s/%d-%d-0000", $temp_dir, $$, time());
               sub temp_file {
                   local *FH;
                   my $count = 0;
                   until (defined(fileno(FH)) ││ $count++ > 100) {
                       $base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
                       # O_EXCL is required for security reasons.
                       sysopen(FH, $base_name, O_WRONLY│O_EXCL│O_CREAT);
                   }
                   if (defined(fileno(FH))
                       return (*FH, $base_name);
                   } else {
                       return ();
                   }
               }
           }

       HHooww ccaann II mmaanniippuullaattee ffiixxeedd--rreeccoorrdd--lleennggtthh ffiilleess??

       The most efficient way is using _p_a_c_k_(_) and _u_n_p_a_c_k_(_).  This is faster
       than using _s_u_b_s_t_r_(_) when taking many, many strings.  It is slower for
       just a few.

       Here is a sample chunk of code to break up and put back together again
       some fixed-format input lines, in this case from the output of a nor-
       mal, Berkeley-style ps:

           # sample input line:
           #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
           my $PS_T = ’A6 A4 A7 A5 A*’;
           open my $ps, ’-│’, ’ps’;
           print scalar <$ps>;
           my @fields = qw( pid tt stat time command );
           while (<$ps>) {
               my %process;
               @process{@fields} = unpack($PS_T, $_);
               for my $field ( @fields ) {
                   print "$field: <$process{$field}>\n";
               }
               print ’line=’, pack($PS_T, @process{@fields} ), "\n";
           }

       We’ve used a hash slice in order to easily handle the fields of each
       row.  Storing the keys in an array means it’s easy to operate on them
       as a group or loop over them with for. It also avoids polluting the
       program with global variables and using symbolic references.

       HHooww ccaann II mmaakkee aa ffiilleehhaannddllee llooccaall ttoo aa ssuubbrroouuttiinnee??  HHooww ddoo II ppaassss ffiillee--
       hhaannddlleess bbeettwweeeenn ssuubbrroouuttiinneess??  HHooww ddoo II mmaakkee aann aarrrraayy ooff ffiilleehhaannddlleess??

       As of perl5.6, _o_p_e_n_(_) autovivifies file and directory handles as refer-
       ences if you pass it an uninitialized scalar variable.  You can then
       pass these references just like any other scalar, and use them in the
       place of named handles.

               open my    $fh, $file_name;

               open local $fh, $file_name;

               print $fh "Hello World!\n";

               process_file( $fh );

       Before perl5.6, you had to deal with various typeglob idioms which you
       may see in older code.

               open FILE, "> $filename";
               process_typeglob(   *FILE );
               process_reference( \*FILE );

               sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
               sub process_reference { local $fh = shift; print $fh "Reference!" }

       If you want to create many anonymous handles, you should check out the
       Symbol or IO::Handle modules.

       HHooww ccaann II uussee aa ffiilleehhaannddllee iinnddiirreeccttllyy??

       An indirect filehandle is using something other than a symbol in a
       place that a filehandle is expected.  Here are ways to get indirect
       filehandles:

           $fh =   SOME_FH;       # bareword is strict-subs hostile
           $fh =  "SOME_FH";      # strict-refs hostile; same package only
           $fh =  *SOME_FH;       # typeglob
           $fh = \*SOME_FH;       # ref to typeglob (bless-able)
           $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob

       Or, you can use the "new" method from one of the IO::* modules to cre-
       ate an anonymous filehandle, store that in a scalar variable, and use
       it as though it were a normal filehandle.

           use IO::Handle;                     # 5.004 or higher
           $fh = IO::Handle->new();

       Then use any of those as you would a normal filehandle.  Anywhere that
       Perl is expecting a filehandle, an indirect filehandle may be used
       instead. An indirect filehandle is just a scalar variable that contains
       a filehandle.  Functions like "print", "open", "seek", or the "<FH>"
       diamond operator will accept either a named filehandle or a scalar
       variable containing one:

           ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
           print $ofh "Type it: ";
           $got = <$ifh>
           print $efh "What was that: $got";

       If you’re passing a filehandle to a function, you can write the func-
       tion in two ways:

           sub accept_fh {
               my $fh = shift;
               print $fh "Sending to indirect filehandle\n";
           }

       Or it can localize a typeglob and use the filehandle directly:

           sub accept_fh {
               local *FH = shift;
               print  FH "Sending to localized filehandle\n";
           }

       Both styles work with either objects or typeglobs of real filehandles.
       (They might also work with strings under some circumstances, but this
       is risky.)

           accept_fh(*STDOUT);
           accept_fh($handle);

       In the examples above, we assigned the filehandle to a scalar variable
       before using it.  That is because only simple scalar variables, not
       expressions or subscripts of hashes or arrays, can be used with built-
       ins like "print", "printf", or the diamond operator.  Using something
       other than a simple scalar variable as a filehandle is illegal and
       won’t even compile:

           @fd = (*STDIN, *STDOUT, *STDERR);
           print $fd[1] "Type it: ";                           # WRONG
           $got = <$fd[0]>                                     # WRONG
           print $fd[2] "What was that: $got";                 # WRONG

       With "print" and "printf", you get around this by using a block and an
       expression where you would place the filehandle:

           print  { $fd[1] } "funny stuff\n";
           printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
           # Pity the poor deadbeef.

       That block is a proper block like any other, so you can put more com-
       plicated code there.  This sends the message out to one of two places:

           $ok = -x "/bin/cat";
           print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
           print { $fd[ 1+ ($ok ││ 0) ]  } "cat stat $ok\n";

       This approach of treating "print" and "printf" like object methods
       calls doesn’t work for the diamond operator.  That’s because it’s a
       real operator, not just a function with a comma-less argument.  Assum-
       ing you’ve been storing typeglobs in your structure as we did above,
       you can use the built-in function named "readline" to read a record
       just as "<>" does.  Given the initialization shown above for @fd, this
       would work, but only because _r_e_a_d_l_i_n_e_(_) requires a typeglob.  It
       doesn’t work with objects or strings, which might be a bug we haven’t
       fixed yet.

           $got = readline($fd[0]);

       Let it be noted that the flakiness of indirect filehandles is not
       related to whether they’re strings, typeglobs, objects, or anything
       else.  It’s the syntax of the fundamental operators.  Playing the
       object game doesn’t help you at all here.

       HHooww ccaann II sseett uupp aa ffooootteerr ffoorrmmaatt ttoo bbee uusseedd wwiitthh _w_r_i_t_e_(_)??

       There’s no builtin way to do this, but perlform has a couple of tech-
       niques to make it possible for the intrepid hacker.

       HHooww ccaann II _w_r_i_t_e_(_) iinnttoo aa ssttrriinngg??

       See "Accessing Formatting Internals" in perlform for an _s_w_r_i_t_e_(_) func-
       tion.

       HHooww ccaann II oouuttppuutt mmyy nnuummbbeerrss wwiitthh ccoommmmaass aaddddeedd??

       (contributed by brian d foy and Benjamin Goldberg)

       You can use Number::Format to separate places in a number.  It handles
       locale information for those of you who want to insert full stops
       instead (or anything else that they want to use, really).

       This subroutine will add commas to your number:

               sub commify {
                  local $_  = shift;
                  1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
                  return $_;
                  }

       This regex from Benjamin Goldberg will add commas to numbers:

          s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))│\G\d{3}(?=\d))/$1,/g;

       It is easier to see with comments:

          s/(
              ^[-+]?            # beginning of number.
              \d+?              # first digits before first comma
              (?=               # followed by, (but not included in the match) :
                 (?>(?:\d{3})+) # some positive multiple of three digits.
                 (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
              )
             │                  # or:
              \G\d{3}           # after the last group, get three digits
              (?=\d)            # but they have to have more digits after them.
          )/$1,/xg;

       HHooww ccaann II ttrraannssllaattee ttiillddeess ((~~)) iinn aa ffiilleennaammee??

       Use the <> (_g_l_o_b_(_)) operator, documented in perlfunc.  Older versions
       of Perl require that you have a shell installed that groks tildes.
       Recent perl versions have this feature built in. The File::KGlob module
       (available from CPAN) gives more portable glob functionality.

       Within Perl, you may use this directly:

               $filename =~ s{
                 ^ ~             # find a leading tilde
                 (               # save this in $1
                     [^/]        # a non-slash character
                           *     # repeated 0 or more times (0 means me)
                 )
               }{
                 $1
                     ? (getpwnam($1))[7]
                     : ( $ENV{HOME} ││ $ENV{LOGDIR} )
               }ex;

       HHooww ccoommee wwhheenn II ooppeenn aa ffiillee rreeaadd--wwrriittee iitt wwiippeess iitt oouutt??

       Because you’re using something like this, which truncates the file and
       _t_h_e_n gives you read-write access:

           open(FH, "+> /path/name");          # WRONG (almost always)

       Whoops.  You should instead use this, which will fail if the file
       doesn’t exist.

           open(FH, "+< /path/name");          # open for update

       Using ">" always clobbers or creates.  Using "<" never does either.
       The "+" doesn’t change this.

       Here are examples of many kinds of file opens.  Those using _s_y_s_o_p_e_n_(_)
       all assume

           use Fcntl;

       To open file for reading:

           open(FH, "< $path")                                 ││ die $!;
           sysopen(FH, $path, O_RDONLY)                        ││ die $!;

       To open file for writing, create new file if needed or else truncate
       old file:

           open(FH, "> $path") ││ die $!;
           sysopen(FH, $path, O_WRONLY│O_TRUNC│O_CREAT)        ││ die $!;
           sysopen(FH, $path, O_WRONLY│O_TRUNC│O_CREAT, 0666)  ││ die $!;

       To open file for writing, create new file, file must not exist:

           sysopen(FH, $path, O_WRONLY│O_EXCL│O_CREAT)         ││ die $!;
           sysopen(FH, $path, O_WRONLY│O_EXCL│O_CREAT, 0666)   ││ die $!;

       To open file for appending, create if necessary:

           open(FH, ">> $path") ││ die $!;
           sysopen(FH, $path, O_WRONLY│O_APPEND│O_CREAT)       ││ die $!;
           sysopen(FH, $path, O_WRONLY│O_APPEND│O_CREAT, 0666) ││ die $!;

       To open file for appending, file must exist:

           sysopen(FH, $path, O_WRONLY│O_APPEND)               ││ die $!;

       To open file for update, file must exist:

           open(FH, "+< $path")                                ││ die $!;
           sysopen(FH, $path, O_RDWR)                          ││ die $!;

       To open file for update, create file if necessary:

           sysopen(FH, $path, O_RDWR│O_CREAT)                  ││ die $!;
           sysopen(FH, $path, O_RDWR│O_CREAT, 0666)            ││ die $!;

       To open file for update, file must not exist:

           sysopen(FH, $path, O_RDWR│O_EXCL│O_CREAT)           ││ die $!;
           sysopen(FH, $path, O_RDWR│O_EXCL│O_CREAT, 0666)     ││ die $!;

       To open a file without blocking, creating if necessary:

           sysopen(FH, "/foo/somefile", O_WRONLY│O_NDELAY│O_CREAT)
                   or die "can’t open /foo/somefile: $!":

       Be warned that neither creation nor deletion of files is guaranteed to
       be an atomic operation over NFS.  That is, two processes might both
       successfully create or unlink the same file!  Therefore O_EXCL isn’t as
       exclusive as you might wish.

       See also the new perlopentut if you have it (new for 5.6).

       WWhhyy ddoo II ssoommeettiimmeess ggeett aann ""AArrgguummeenntt lliisstt ttoooo lloonngg"" wwhheenn II uussee <<**>>??

       The "<>" operator performs a globbing operation (see above).  In Perl
       versions earlier than v5.6.0, the internal _g_l_o_b_(_) operator forks _c_s_h(1)
       to do the actual glob expansion, but csh can’t handle more than 127
       items and so gives the error message "Argument list too long".  People
       who installed tcsh as csh won’t have this problem, but their users may
       be surprised by it.

       To get around this, either upgrade to Perl v5.6.0 or later, do the glob
       yourself with _r_e_a_d_d_i_r_(_) and patterns, or use a module like File::KGlob,
       one that doesn’t use the shell to do globbing.

       IIss tthheerree aa lleeaakk//bbuugg iinn _g_l_o_b_(_)??

       Due to the current implementation on some operating systems, when you
       use the _g_l_o_b_(_) function or its angle-bracket alias in a scalar context,
       you may cause a memory leak and/or unpredictable behavior.  It’s best
       therefore to use _g_l_o_b_(_) only in list context.

       HHooww ccaann II ooppeenn aa ffiillee wwiitthh aa lleeaaddiinngg "">>"" oorr ttrraaiilliinngg bbllaannkkss??

       (contributed by Brian McCauley)

       The special two argument form of Perl’s _o_p_e_n_(_) function ignores trail-
       ing blanks in filenames and infers the mode from certain leading char-
       acters (or a trailing "│"). In older versions of Perl this was the only
       version of _o_p_e_n_(_) and so it is prevalent in old code and books.

       Unless you have a particular reason to use the two argument form you
       should use the three argument form of _o_p_e_n_(_) which does not treat any
       charcters in the filename as special.

               open FILE, "<", "  file  ";  # filename is "   file   "
               open FILE, ">", ">file";     # filename is ">file"

       HHooww ccaann II rreelliiaabbllyy rreennaammee aa ffiillee??

       If your operating system supports a proper _m_v(1) utility or its func-
       tional equivalent, this works:

           rename($old, $new) or system("mv", $old, $new);

       It may be more portable to use the File::Copy module instead.  You just
       copy to the new file to the new name (checking return values), then
       delete the old one.  This isn’t really the same semantically as a
       _r_e_n_a_m_e_(_), which preserves meta-information like permissions, times-
       tamps, inode info, etc.

       Newer versions of File::Copy export a _m_o_v_e_(_) function.

       HHooww ccaann II lloocckk aa ffiillee??

       Perl’s builtin _f_l_o_c_k_(_) function (see perlfunc for details) will call
       _f_l_o_c_k(2) if that exists, _f_c_n_t_l(2) if it doesn’t (on perl version 5.004
       and later), and _l_o_c_k_f(3) if neither of the two previous system calls
       exists.  On some systems, it may even use a different form of native
       locking.  Here are some gotchas with Perl’s _f_l_o_c_k_(_):

       1   Produces a fatal error if none of the three system calls (or their
           close equivalent) exists.

       2   _l_o_c_k_f(3) does not provide shared locking, and requires that the
           filehandle be open for writing (or appending, or read/writing).

       3   Some versions of _f_l_o_c_k_(_) can’t lock files over a network (e.g. on
           NFS file systems), so you’d need to force the use of _f_c_n_t_l(2) when
           you build Perl.  But even this is dubious at best.  See the flock
           entry of perlfunc and the _I_N_S_T_A_L_L file in the source distribution
           for information on building Perl to do this.

           Two potentially non-obvious but traditional flock semantics are
           that it waits indefinitely until the lock is granted, and that its
           locks are _m_e_r_e_l_y _a_d_v_i_s_o_r_y.  Such discretionary locks are more flex-
           ible, but offer fewer guarantees.  This means that files locked
           with _f_l_o_c_k_(_) may be modified by programs that do not also use
           _f_l_o_c_k_(_).  Cars that stop for red lights get on well with each
           other, but not with cars that don’t stop for red lights.  See the
           perlport manpage, your port’s specific documentation, or your sys-
           tem-specific local manpages for details.  It’s best to assume tra-
           ditional behavior if you’re writing portable programs.  (If you’re
           not, you should as always feel perfectly free to write for your own
           system’s idiosyncrasies (sometimes called "features").  Slavish
           adherence to portability concerns shouldn’t get in the way of your
           getting your job done.)

           For more information on file locking, see also "File Locking" in
           perlopentut if you have it (new for 5.6).

       WWhhyy ccaann’’tt II jjuusstt ooppeenn((FFHH,, "">>ffiillee..lloocckk""))??

       A common bit of code NNOOTT TTOO UUSSEE is this:

           sleep(3) while -e "file.lock";      # PLEASE DO NOT USE
           open(LCK, "> file.lock");           # THIS BROKEN CODE

       This is a classic race condition: you take two steps to do something
       which must be done in one.  That’s why computer hardware provides an
       atomic test-and-set instruction.   In theory, this "ought" to work:

           sysopen(FH, "file.lock", O_WRONLY│O_EXCL│O_CREAT)
                       or die "can’t open  file.lock: $!";

       except that lamentably, file creation (and deletion) is not atomic over
       NFS, so this won’t work (at least, not every time) over the net.  Vari-
       ous schemes involving _l_i_n_k_(_) have been suggested, but these tend to
       involve busy-wait, which is also subdesirable.

       II ssttiillll ddoonn’’tt ggeett lloocckkiinngg..  II jjuusstt wwaanntt ttoo iinnccrreemmeenntt tthhee nnuummbbeerr iinn tthhee
       ffiillee..  HHooww ccaann II ddoo tthhiiss??

       Didn’t anyone ever tell you web-page hit counters were useless?  They
       don’t count number of hits, they’re a waste of time, and they serve
       only to stroke the writer’s vanity.  It’s better to pick a random num-
       ber; they’re more realistic.

       Anyway, this is what you can do if you can’t help yourself.

           use Fcntl qw(:DEFAULT :flock);
           sysopen(FH, "numfile", O_RDWR│O_CREAT)       or die "can’t open numfile: $!";
           flock(FH, LOCK_EX)                           or die "can’t flock numfile: $!";
           $num = <FH> ││ 0;
           seek(FH, 0, 0)                               or die "can’t rewind numfile: $!";
           truncate(FH, 0)                              or die "can’t truncate numfile: $!";
           (print FH $num+1, "\n")                      or die "can’t write numfile: $!";
           close FH                                     or die "can’t close numfile: $!";

       Here’s a much better web-page hit counter:

           $hits = int( (time() - 850_000_000) / rand(1_000) );

       If the count doesn’t impress your friends, then the code might.  :-)

       AAllll II wwaanntt ttoo ddoo iiss aappppeenndd aa ssmmaallll aammoouunntt ooff tteexxtt ttoo tthhee eenndd ooff aa ffiillee..
       DDoo II ssttiillll hhaavvee ttoo uussee lloocckkiinngg??

       If you are on a system that correctly implements _f_l_o_c_k_(_) and you use
       the example appending code from "perldoc -f flock" everything will be
       OK even if the OS you are on doesn’t implement append mode correctly
       (if such a system exists.) So if you are happy to restrict yourself to
       OSs that implement _f_l_o_c_k_(_) (and that’s not really much of a restric-
       tion) then that is what you should do.

       If you know you are only going to use a system that does correctly
       implement appending (i.e. not Win32) then you can omit the _s_e_e_k_(_) from
       the above code.

       If you know you are only writing code to run on an OS and filesystem
       that does implement append mode correctly (a local filesystem on a mod-
       ern Unix for example), and you keep the file in block-buffered mode and
       you write less than one buffer-full of output between each manual
       flushing of the buffer then each bufferload is almost guaranteed to be
       written to the end of the file in one chunk without getting intermin-
       gled with anyone else’s output. You can also use the _s_y_s_w_r_i_t_e_(_) func-
       tion which is simply a wrapper around your systems _w_r_i_t_e(2) system
       call.

       There is still a small theoretical chance that a signal will interrupt
       the system level _w_r_i_t_e_(_) operation before completion.  There is also a
       possibility that some STDIO implementations may call multiple system
       level _w_r_i_t_e_(_)s even if the buffer was empty to start.  There may be
       some systems where this probability is reduced to zero.

       HHooww ddoo II rraannddoommllyy uuppddaattee aa bbiinnaarryy ffiillee??

       If you’re just trying to patch a binary, in many cases something as
       simple as this works:

           perl -i -pe ’s{window manager}{window mangler}g’ /usr/bin/emacs

       However, if you have fixed sized records, then you might do something
       more like this:

           $RECSIZE = 220; # size of record, in bytes
           $recno   = 37;  # which record to update
           open(FH, "+<somewhere") ││ die "can’t update somewhere: $!";
           seek(FH, $recno * $RECSIZE, 0);
           read(FH, $record, $RECSIZE) == $RECSIZE ││ die "can’t read record $recno: $!";
           # munge the record
           seek(FH, -$RECSIZE, 1);
           print FH $record;
           close FH;

       Locking and error checking are left as an exercise for the reader.
       Don’t forget them or you’ll be quite sorry.

       HHooww ddoo II ggeett aa ffiillee’’ss ttiimmeessttaammpp iinn ppeerrll??

       If you want to retrieve the time at which the file was last read, writ-
       ten, or had its meta-data (owner, etc) changed, you use the --AA, --MM, or
       --CC file test operations as documented in perlfunc.  These retrieve the
       age of the file (measured against the start-time of your program) in
       days as a floating point number. Some platforms may not have all of
       these times.  See perlport for details. To retrieve the "raw" time in
       seconds since the epoch, you would call the stat function, then use
       _l_o_c_a_l_t_i_m_e_(_), _g_m_t_i_m_e_(_), or _P_O_S_I_X_:_:_s_t_r_f_t_i_m_e_(_) to convert this into human-
       readable form.

       Here’s an example:

           $write_secs = (stat($file))[9];
           printf "file %s updated at %s\n", $file,
               scalar localtime($write_secs);

       If you prefer something more legible, use the File::stat module (part
       of the standard distribution in version 5.004 and later):

           # error checking left as an exercise for reader.
           use File::stat;
           use Time::localtime;
           $date_string = ctime(stat($file)->mtime);
           print "file $file updated at $date_string\n";

       The _P_O_S_I_X_:_:_s_t_r_f_t_i_m_e_(_) approach has the benefit of being, in theory,
       independent of the current locale.  See perllocale for details.

       HHooww ddoo II sseett aa ffiillee’’ss ttiimmeessttaammpp iinn ppeerrll??

       You use the _u_t_i_m_e_(_) function documented in "utime" in perlfunc.  By way
       of example, here’s a little program that copies the read and write
       times from its first argument to all the rest of them.

           if (@ARGV < 2) {
               die "usage: cptimes timestamp_file other_files ...\n";
           }
           $timestamp = shift;
           ($atime, $mtime) = (stat($timestamp))[8,9];
           utime $atime, $mtime, @ARGV;

       Error checking is, as usual, left as an exercise for the reader.

       The perldoc for utime also has an example that has the same effect as
       _t_o_u_c_h(1) on files that _a_l_r_e_a_d_y _e_x_i_s_t.

       Certain file systems have a limited ability to store the times on a
       file at the expected level of precision.  For example, the FAT and HPFS
       filesystem are unable to create dates on files with a finer granularity
       than two seconds.  This is a limitation of the filesystems, not of
       _u_t_i_m_e_(_).

       HHooww ddoo II pprriinntt ttoo mmoorree tthhaann oonnee ffiillee aatt oonnccee??

       To connect one filehandle to several output filehandles, you can use
       the IO::Tee or Tie::FileHandle::Multiplex modules.

       If you only have to do this once, you can print individually to each
       filehandle.

           for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }

       HHooww ccaann II rreeaadd iinn aann eennttiirree ffiillee aallll aatt oonnccee??

       You can use the File::Slurp module to do it in one step.

               use File::Slurp;

               $all_of_it = read_file($filename); # entire file in scalar
           @all_lines = read_file($filename); # one line perl element

       The customary Perl approach for processing all the lines in a file is
       to do so one line at a time:

           open (INPUT, $file)         ││ die "can’t open $file: $!";
           while (<INPUT>) {
               chomp;
               # do something with $_
           }
           close(INPUT)                ││ die "can’t close $file: $!";

       This is tremendously more efficient than reading the entire file into
       memory as an array of lines and then processing it one element at a
       time, which is often--if not almost always--the wrong approach.  When-
       ever you see someone do this:

           @lines = <INPUT>;

       you should think long and hard about why you need everything loaded at
       once.  It’s just not a scalable solution.  You might also find it more
       fun to use the standard Tie::File module, or the DB_File module’s
       $DB_RECNO bindings, which allow you to tie an array to a file so that
       accessing an element the array actually accesses the corresponding line
       in the file.

       You can read the entire filehandle contents into a scalar.

           {
               local(*INPUT, $/);
               open (INPUT, $file)     ││ die "can’t open $file: $!";
               $var = <INPUT>;
           }

       That temporarily undefs your record separator, and will automatically
       close the file at block exit.  If the file is already open, just use
       this:

           $var = do { local $/; <INPUT> };

       For ordinary files you can also use the read function.

               read( INPUT, $var, -s INPUT );

       The third argument tests the byte size of the data on the INPUT file-
       handle and reads that many bytes into the buffer $var.

       HHooww ccaann II rreeaadd iinn aa ffiillee bbyy ppaarraaggrraapphhss??

       Use the $/ variable (see perlvar for details).  You can either set it
       to "" to eliminate empty paragraphs ("abc\n\n\n\ndef", for instance,
       gets treated as two paragraphs and not three), or "\n\n" to accept
       empty paragraphs.

       Note that a blank line must have no blanks in it.  Thus
       "fred\n \nstuff\n\n" is one paragraph, but "fred\n\nstuff\n\n" is two.

       HHooww ccaann II rreeaadd aa ssiinnggllee cchhaarraacctteerr ffrroomm aa ffiillee??  FFrroomm tthhee kkeeyybbooaarrdd??

       You can use the builtin "getc()" function for most filehandles, but it
       won’t (easily) work on a terminal device.  For STDIN, either use the
       Term::ReadKey module from CPAN or use the sample code in "getc" in
       perlfunc.

       If your system supports the portable operating system programming
       interface (POSIX), you can use the following code, which you’ll note
       turns off echo processing as well.

           #!/usr/bin/perl -w
           use strict;
           $│ = 1;
           for (1..4) {
               my $got;
               print "gimme: ";
               $got = getone();
               print "--> $got\n";
           }
           exit;

           BEGIN {
               use POSIX qw(:termios_h);

               my ($term, $oterm, $echo, $noecho, $fd_stdin);

               $fd_stdin = fileno(STDIN);

               $term     = POSIX::Termios->new();
               $term->getattr($fd_stdin);
               $oterm     = $term->getlflag();

               $echo     = ECHO │ ECHOK │ ICANON;
               $noecho   = $oterm & ~$echo;

               sub cbreak {
                   $term->setlflag($noecho);
                   $term->setcc(VTIME, 1);
                   $term->setattr($fd_stdin, TCSANOW);
               }

               sub cooked {
                   $term->setlflag($oterm);
                   $term->setcc(VTIME, 0);
                   $term->setattr($fd_stdin, TCSANOW);
               }

               sub getone {
                   my $key = ’’;
                   cbreak();
                   sysread(STDIN, $key, 1);
                   cooked();
                   return $key;
               }

           }

           END { cooked() }

       The Term::ReadKey module from CPAN may be easier to use.  Recent ver-
       sions include also support for non-portable systems as well.

           use Term::ReadKey;
           open(TTY, "</dev/tty");
           print "Gimme a char: ";
           ReadMode "raw";
           $key = ReadKey 0, *TTY;
           ReadMode "normal";
           printf "\nYou said %s, char number %03d\n",
               $key, ord $key;

       HHooww ccaann II tteellll wwhheetthheerr tthheerree’’ss aa cchhaarraacctteerr wwaaiittiinngg oonn aa ffiilleehhaannddllee??

       The very first thing you should do is look into getting the Term::Read-
       Key extension from CPAN.  As we mentioned earlier, it now even has lim-
       ited support for non-portable (read: not open systems, closed, propri-
       etary, not POSIX, not Unix, etc) systems.

       You should also check out the Frequently Asked Questions list in
       comp.unix.* for things like this: the answer is essentially the same.
       It’s very system dependent.  Here’s one solution that works on BSD sys-
       tems:

           sub key_ready {
               my($rin, $nfd);
               vec($rin, fileno(STDIN), 1) = 1;
               return $nfd = select($rin,undef,undef,0);
           }

       If you want to find out how many characters are waiting, there’s also
       the FIONREAD ioctl call to be looked at.  The _h_2_p_h tool that comes with
       Perl tries to convert C include files to Perl code, which can be
       "require"d.  FIONREAD ends up defined as a function in the _s_y_s_/_i_o_c_t_l_._p_h
       file:

           require ’sys/ioctl.ph’;

           $size = pack("L", 0);
           ioctl(FH, FIONREAD(), $size)    or die "Couldn’t call ioctl: $!\n";
           $size = unpack("L", $size);

       If _h_2_p_h wasn’t installed or doesn’t work for you, you can _g_r_e_p the
       include files by hand:

           % grep FIONREAD /usr/include/*/*
           /usr/include/asm/ioctls.h:#define FIONREAD      0x541B

       Or write a small C program using the editor of champions:

           % cat > fionread.c
           #include <sys/ioctl.h>
           main() {
               printf("%#08x\n", FIONREAD);
           }
           ^D
           % cc -o fionread fionread.c
           % ./fionread
           0x4004667f

       And then hard code it, leaving porting as an exercise to your succes-
       sor.

           $FIONREAD = 0x4004667f;         # XXX: opsys dependent

           $size = pack("L", 0);
           ioctl(FH, $FIONREAD, $size)     or die "Couldn’t call ioctl: $!\n";
           $size = unpack("L", $size);

       FIONREAD requires a filehandle connected to a stream, meaning that
       sockets, pipes, and tty devices work, but _n_o_t files.

       HHooww ddoo II ddoo aa ""ttaaiill --ff"" iinn ppeerrll??

       First try

           seek(GWFILE, 0, 1);

       The statement "seek(GWFILE, 0, 1)" doesn’t change the current position,
       but it does clear the end-of-file condition on the handle, so that the
       next <GWFILE> makes Perl try again to read something.

       If that doesn’t work (it relies on features of your stdio implementa-
       tion), then you need something more like this:

               for (;;) {
                 for ($curpos = tell(GWFILE); <GWFILE>; $curpos = tell(GWFILE)) {
                   # search for some stuff and put it into files
                 }
                 # sleep for a while
                 seek(GWFILE, $curpos, 0);  # seek to where we had been
               }

       If this still doesn’t work, look into the POSIX module.  POSIX defines
       the _c_l_e_a_r_e_r_r_(_) method, which can remove the end of file condition on a
       filehandle.  The method: read until end of file, _c_l_e_a_r_e_r_r_(_), read some
       more.  Lather, rinse, repeat.

       There’s also a File::Tail module from CPAN.

       HHooww ddoo II _d_u_p_(_) aa ffiilleehhaannddllee iinn PPeerrll??

       If you check "open" in perlfunc, you’ll see that several of the ways to
       call _o_p_e_n_(_) should do the trick.  For example:

           open(LOG, ">>/foo/logfile");
           open(STDERR, ">&LOG");

       Or even with a literal numeric descriptor:

          $fd = $ENV{MHCONTEXTFD};
          open(MHCONTEXT, "<&=$fd");   # like fdopen(3S)

       Note that "<&STDIN" makes a copy, but "<&=STDIN" make an alias.  That
       means if you close an aliased handle, all aliases become inaccessible.
       This is not true with a copied one.

       Error checking, as always, has been left as an exercise for the reader.

       HHooww ddoo II cclloossee aa ffiillee ddeessccrriippttoorr bbyy nnuummbbeerr??

       This should rarely be necessary, as the Perl _c_l_o_s_e_(_) function is to be
       used for things that Perl opened itself, even if it was a dup of a
       numeric descriptor as with MHCONTEXT above.  But if you really have to,
       you may be able to do this:

           require ’sys/syscall.ph’;
           $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
           die "can’t sysclose $fd: $!" unless $rc == -1;

       Or, just use the fdopen(3S) feature of _o_p_e_n_(_):

           {
               local *F;
               open F, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
               close F;
           }

       WWhhyy ccaann’’tt II uussee ""CC::\\tteemmpp\\ffoooo"" iinn DDOOSS ppaatthhss??  WWhhyy ddooeessnn’’tt
       ‘‘CC::\\tteemmpp\\ffoooo..eexxee‘‘ wwoorrkk??

       Whoops!  You just put a tab and a formfeed into that filename!  Remem-
       ber that within double quoted strings ("like\this"), the backslash is
       an escape character.  The full list of these is in "Quote and Quote-
       like Operators" in perlop.  Unsurprisingly, you don’t have a file
       called "c:(tab)emp(formfeed)oo" or "c:(tab)emp(formfeed)oo.exe" on your
       legacy DOS filesystem.

       Either single-quote your strings, or (preferably) use forward slashes.
       Since all DOS and Windows versions since something like MS-DOS 2.0 or
       so have treated "/" and "\" the same in a path, you might as well use
       the one that doesn’t clash with Perl--or the POSIX shell, ANSI C and
       C++, awk, Tcl, Java, or Python, just to mention a few.  POSIX paths are
       more portable, too.

       WWhhyy ddooeessnn’’tt gglloobb((""**..**"")) ggeett aallll tthhee ffiilleess??

       Because even on non-Unix ports, Perl’s glob function follows standard
       Unix globbing semantics.  You’ll need "glob("*")" to get all (non-hid-
       den) files.  This makes _g_l_o_b_(_) portable even to legacy systems.  Your
       port may include proprietary globbing functions as well.  Check its
       documentation for details.

       WWhhyy ddooeess PPeerrll lleett mmee ddeelleettee rreeaadd--oonnllyy ffiilleess??  WWhhyy ddooeess ""--ii"" cclloobbbbeerr
       pprrootteecctteedd ffiilleess??  IIssnn’’tt tthhiiss aa bbuugg iinn PPeerrll??

       This is elaborately and painstakingly described in the _f_i_l_e_-_d_i_r_-_p_e_r_m_s
       article in the "Far More Than You Ever Wanted To Know" collection in
       http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .

       The executive summary: learn how your filesystem works.  The permis-
       sions on a file say what can happen to the data in that file.  The per-
       missions on a directory say what can happen to the list of files in
       that directory.  If you delete a file, you’re removing its name from
       the directory (so the operation depends on the permissions of the
       directory, not of the file).  If you try to write to the file, the per-
       missions of the file govern whether you’re allowed to.

       HHooww ddoo II sseelleecctt aa rraannddoomm lliinnee ffrroomm aa ffiillee??

       Here’s an algorithm from the Camel Book:

           srand;
           rand($.) < 1 && ($line = $_) while <>;

       This has a significant advantage in space over reading the whole file
       in.  You can find a proof of this method in _T_h_e _A_r_t _o_f _C_o_m_p_u_t_e_r _P_r_o_-
       _g_r_a_m_m_i_n_g, Volume 2, Section 3.4.2, by Donald E. Knuth.

       You can use the File::Random module which provides a function for that
       algorithm:

               use File::Random qw/random_line/;
               my $line = random_line($filename);

       Another way is to use the Tie::File module, which treats the entire
       file as an array.  Simply access a random array element.

       WWhhyy ddoo II ggeett wweeiirrdd ssppaacceess wwhheenn II pprriinntt aann aarrrraayy ooff lliinneess??

       Saying

           print "@lines\n";

       joins together the elements of @lines with a space between them.  If
       @lines were "("little", "fluffy", "clouds")" then the above statement
       would print

           little fluffy clouds

       but if each element of @lines was a line of text, ending a newline
       character "("little\n", "fluffy\n", "clouds\n")" then it would print:

           little
            fluffy
            clouds

       If your array contains lines, just print them:

           print @lines;

AAUUTTHHOORR AANNDD CCOOPPYYRRIIGGHHTT
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other
       authors as noted. All rights reserved.

       This documentation is free; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       Irrespective of its distribution, all code examples here are in the
       public domain.  You are permitted and encouraged to use this code and
       any derivatives thereof in your own programs for fun or for profit as
       you see fit.  A simple comment in the code giving credit to the FAQ
       would be courteous but is not required.



perl v5.8.8                       2013-03-27                       PERLFAQ5(1)
